#!/usr/bin/env python3

# File: depcp.py
#
# Description:
#   A utility designed to find and package shared library dependencies for a Linux executable.
#   This script takes an executable file as input, uses the 'ldd' command to recursively find
#   all its direct and indirect shared library dependencies, and copies the executable
#   along with all found dependency files to a specified target directory.
#   The copying process preserves the original directory structure from the
#   filesystem root within the target directory.
#
#   Note: This tool primarily handles statically linked and direct shared libraries
#         discoverable via 'ldd'. It does NOT automatically handle libraries
#         loaded dynamically at runtime (e.g., using dlopen), configuration files
#         (e.g., in /etc), data files, locales, man pages, documentation, necessary
#         device nodes (in /dev), or essential system directories (like /proc, /sys, /tmp).
#         Additional manual steps or more sophisticated tools may be required for
#         a fully functional minimal environment or container rootfs.
#
# Purpose: To assist in creating minimal environments or packages for executables
#          by collecting their core shared library requirements, aiding portability.
#
# Date: 2025-04-18
# Version: 1.0.0
#
# License:
#   This code is licensed under the GNU General Public License Version 3.
#   You should have received a copy of the GNU General Public License along with this program.
#   If not, see <https://www.gnu.org/licenses/>.
#   See the accompanying LICENSE file for the full license text.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright:
#   Copyright (c) 2025, Naiin9 <naiin9@outlook.com>
#
# Note on Creation:
#   The initial code structure and implementation for this utility were generated by
#   Gemini (A large language model, trained by Google) based on the design, requirements,
#   and direction provided by the copyright holder.
#

import subprocess
import re
import sys
import os
import shutil
from pathlib import Path
from collections import deque
import argparse

# Regular expression to parse ldd output lines
# Group 1: Library name (before =>) - not directly used here
# Group 2: Full path to the library (after =>) or interpreter path
LDD_LINE_RE = re.compile(r'\s*(.+)\s+=>\s+(.+)\s+\(0x[0-9a-f]+\)')
# For interpreter lines like /lib64/ld-linux-x86-64.so.2
LDD_INTERP_RE = re.compile(r'^\s*(/[^ ]+)\s+\(0x[0-9a-f]+\)')

def parse_ldd_output(output_lines):
    """
    Parse output lines from ldd command and yield dependency file paths.
    Skips lines indicating 'not found' or virtual libraries like vdso.
    """
    for line in output_lines:
        line = line.strip()
        if not line:
            continue

        # Handle lines with '=>'
        match = LDD_LINE_RE.match(line)
        if match:
            lib_path_str = match.group(2).strip()
            if lib_path_str and lib_path_str.lower() != 'not found':
                 # Check if it's a regular file before yielding
                 lib_path = Path(lib_path_str)
                 if lib_path.is_file():
                     yield lib_path
                 # else:
                 #    print(f"Warning: ldd reported '{lib_path_str}' but it's not a regular file.")


        # Handle lines without '=>', like the interpreter path
        # Ensure it's not the virtual vdso path
        else:
             match_interp = LDD_INTERP_RE.match(line)
             if match_interp:
                 lib_path_str = match_interp.group(1).strip()
                 # Check if it's a regular file and not the vdso line
                 if lib_path_str and 'vdso' not in lib_path_str:
                     lib_path = Path(lib_path_str)
                     if lib_path.is_file():
                          yield lib_path
                     # else:
                     #    print(f"Warning: ldd reported interpreter path '{lib_path_str}' but it's not a regular file.")


def get_recursive_dependencies(executable_path: Path):
    """
    Finds all recursive shared library dependencies for an executable using ldd.

    Args:
        executable_path: Path object for the executable.

    Returns:
        A set of Path objects for the executable and all its dependencies.
    """
    paths_to_process = deque([executable_path])
    processed_paths = set()
    files_to_copy = set()

    # Add the initial executable to the set of files to copy
    files_to_copy.add(executable_path)
    processed_paths.add(executable_path) # Mark executable as processed initially

    # print(f"Starting dependency analysis for: {executable_path}") # Moved this print outside or before call

    while paths_to_process:
        current_path = paths_to_process.popleft()

        # print(f"Checking dependencies for: {current_path}") # uncomment for verbose output

        # Check if the path is a regular file before running ldd
        if not current_path.is_file():
             # This case should be rare if only files are added to queue from ldd output,
             # but it's good for robustness.
             print(f"Warning: '{current_path}' is not a regular file or does not exist, skipping dependency check.", file=sys.stderr)
             continue

        try:
            # Run ldd command
            result = subprocess.run(
                ['ldd', str(current_path)],
                capture_output=True,
                text=True, # Decode output as text
                check=True # Raise exception if ldd fails
            )
            ldd_output_lines = result.stdout.splitlines()

        except FileNotFoundError:
            print(f"Error: 'ldd' command not found. Is it installed and in your PATH?", file=sys.stderr)
            # Cannot proceed if ldd is not found, better to exit here
            sys.exit(1)
        except subprocess.CalledProcessError as e:
            print(f"Warning: ldd failed for '{current_path}' (Return code: {e.returncode})\nStderr:\n{e.stderr}", file=sys.stderr)
            # Continue processing other files, but dependencies of this one might be missed
            continue
        except Exception as e:
            print(f"An unexpected error occurred while running ldd on '{current_path}': {e}", file=sys.stderr)
            continue


        # Parse ldd output and add new dependencies to queue and copy list
        for lib_path in parse_ldd_output(ldd_output_lines):
            if lib_path not in processed_paths:
                # print(f"  Found dependency: {lib_path}") # uncomment for verbose output
                paths_to_process.append(lib_path) # Add to the end of the queue for further processing
                files_to_copy.add(lib_path)      # Add to the list of files to copy
                processed_paths.add(lib_path)    # Mark as processed (added to queue or already processed)

    # print(f"Dependency analysis complete for {executable_path}. Found {len(files_to_copy)} files.") # Debug print
    return files_to_copy

def copy_files_preserving_structure(files_to_copy: set[Path], target_rootfs: Path):
    """
    Copies a set of files to a target rootfs, preserving their original path structure.
    e.g., /usr/bin/file -> target_rootfs/usr/bin/file

    Args:
        files_to_copy: A set of Path objects representing files to copy.
        target_rootfs: The root directory where files should be copied.
    """
    print(f"\nCopying {len(files_to_copy)} unique files to: {target_rootfs}")

    for source_path in files_to_copy:
        try:
            # Calculate the target path: target_rootfs + source_path (relative to root)
            # source_path.relative_to('/') gives the path relative from the filesystem root
            target_path = target_rootfs / source_path.relative_to('/')

            # Create parent directories if they don't exist
            target_path.parent.mkdir(parents=True, exist_ok=True)

            # Copy the file, preserving metadata (like timestamps)
            # print(f"Copying: {source_path} to {target_path}") # uncomment for verbose output
            shutil.copy2(source_path, target_path)

        except FileNotFoundError:
             print(f"Error: Source file not found during copy: {source_path}", file=sys.stderr)
             # Continue with other files
        except PermissionError:
             print(f"Error: Permission denied copying '{source_path}' to '{target_path}'. Run with sufficient privileges (e.g., sudo)?", file=sys.stderr)
             # Depending on requirements, you might exit here or continue
        except Exception as e:
            print(f"An unexpected error occurred while copying '{source_path}': {e}", file=sys.stderr)
            # Continue with other files


def main():
    parser = argparse.ArgumentParser(
        description="Collects one or more executables and their recursive shared library dependencies "
                    "and copies them to a target directory preserving the original path structure."
    )
    parser.add_argument(
        "executable_files", # <-- Accepts multiple files
        type=str,
        nargs='+', # <-- Accepts one or more files
        help="Path(s) to the executable file(s)."
    )
    parser.add_argument(
        "target_directory",
        type=str,
        help="Path to the target root filesystem directory."
    )

    args = parser.parse_args()

    # Target directory path resolution and validation (still single target)
    target_rootfs = Path(args.target_directory).resolve()
    if not target_rootfs.is_dir():
        print(f"Error: Target directory not found or is not a directory: {target_rootfs}", file=sys.stderr)
        # Optional: ask user or create the directory here if preferred
        sys.exit(1)


    all_files_to_copy = set() # <--- Set to store all unique files

    print(f"Analyzing {len(args.executable_files)} executable(s)...")

    # --- Loop through each executable file ---
    valid_executables_processed = 0
    for exec_file_str in args.executable_files:
        executable_path = Path(exec_file_str).resolve()

        # Basic validation for each file
        if not executable_path.is_file():
            print(f"\nWarning: Executable file not found or is not a regular file, skipping: {executable_path}", file=sys.stderr)
            continue # Skip this file, proceed to the next

        valid_executables_processed += 1
        print(f"\nProcessing dependencies for: {executable_path}") # Log indicating which file is being processed

        # Call the original function to find dependencies for the current file
        files_for_this_exec = get_recursive_dependencies(executable_path)

        # Add the results to the main Set (Set handles duplicates automatically)
        all_files_to_copy.update(files_for_this_exec)

    # --- End of processing all files ---

    # --- Main Copy Logic ---
    if not all_files_to_copy:
        if valid_executables_processed > 0:
             print("\nNo dependencies collected for the valid executable(s) provided. Nothing to copy.", file=sys.stderr)
        else:
             print("\nNo valid executable files found to process. Exiting.", file=sys.stderr)
        sys.exit(0) # Exit successfully if no files needed/found after processing valid inputs

    print(f"\nTotal unique files collected for all executables: {len(all_files_to_copy)}")

    # Call the copy function once with the set of all files
    copy_files_preserving_structure(all_files_to_copy, target_rootfs)

    print("\n--- Process Complete ---")
    print(f"Copied {len(all_files_to_copy)} unique files to {target_rootfs}")
    print("\n--- Important Considerations ---")
    print("This script copies only the *directly linked* and recursive shared libraries found via ldd.")
    print("It does NOT automatically handle:")
    print("  - Libraries loaded dynamically at runtime (e.g., using dlopen).")
    print("  - Configuration files in /etc (like nsswitch.conf, resolv.conf, timezone data).")
    print("  - Data files, locales, man pages, documentation.")
    print("  - Necessary device nodes in /dev (you might need 'mknod').")
    print("  - Essential directories like /proc, /sys, /tmp (usually mount points).")
    print("  - User/group information (passwd, group).")
    print("For a functional minimal container/environment, you will likely need to manually add these items or use a more sophisticated tool/process like multi-stage Docker builds with minimal base images (e.g., Alpine Linux).")


if __name__ == "__main__":
    main()
